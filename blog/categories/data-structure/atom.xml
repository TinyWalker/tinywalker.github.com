<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Data Structure | Albert Blog]]></title>
  <link href="http://Albert0010.github.io/blog/categories/data-structure/atom.xml" rel="self"/>
  <link href="http://Albert0010.github.io/"/>
  <updated>2013-09-06T00:23:12+08:00</updated>
  <id>http://Albert0010.github.io/</id>
  <author>
    <name><![CDATA[Albert]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[图]]></title>
    <link href="http://Albert0010.github.io/blog/2013/08/29/title/"/>
    <updated>2013-08-29T13:29:00+08:00</updated>
    <id>http://Albert0010.github.io/blog/2013/08/29/title</id>
    <content type="html"><![CDATA[<p>&emsp;在旅游和搭建干线的时候，我们经常遇到求两点之间的最小距离的问题。做出一个合理的规划，既能简单的实现我们的目标，又能减少大量的时间和money。不错，图中最短路径就是针对这些问题的。还等什么，让我们看看图的神奇吧。。。</p>

<!--more-->


<h2>一.基本概念</h2>

<h3>1.图</h3>

<p>图（Graph）是由顶点的有穷非空集合和顶点之间的边的集合组成，表示为：G(V,E)。其中G表示一个图，V表示顶点的集合，E表示边的集合。其中无向图的边用（）表示，有向图的边用&lt;>表示</p>

<h3>2.简单图</h3>

<p>若图中不出现顶点到其自身的边，且同一条边不重复出现，称这样的图为简单图。</p>

<h3>3.无向完全图</h3>

<p>在无向图中，若任意两个顶点之间都存在一条边，则称此图为无向完全图。</p>

<h3>4.有向完全图</h3>

<p>在有向图中，若任意两个顶点之间都存在一对方向相反的边，则称此图为有向完全图。</p>

<h3>5.路径的长度</h3>

<p>路径的长度是指路径上的边（无向图）或弧（有向图）的个数。</p>

<h3>6.简单路径</h3>

<p>序列中的顶点不重复的路径叫做简单路径</p>

<h3>7.简单回路（简单环）</h3>

<p>除第一个顶点和最后一个顶点外，其他的顶点都不重复的回路叫做简单回路（简单环）</p>

<h3>8.连通图</h3>

<p>任意两个顶点都连通的图叫做连通图</p>

<h3>9.连通分量</h3>

<p>无向图中的极大连通子图称为连通分量。 强调几点：</p>

<p>.无向图</p>

<p>.子图且子图是连通的</p>

<p>.子图中含有的顶点数是最大的</p>

<h3>10.强连通图</h3>

<p>在有向图中，如果对于任意一对顶点v<sub>i</sub>,v<sub>j</sub>,既存在v<sub>i</sub>到v<sub>j</sub>的路径，也存在v<sub>j</sub>到v<sub>i</sub>的路径，则称此图为强连通图</p>

<h3>11.强连通分量</h3>

<p>有向图的极大连通子图称为强连通分量</p>

<h2>小结</h2>

<p><code>任意两个顶点连通的图，称为连通图。有向则称为强连通图。在所有子图中，若子图极大连通，则称为连通分量。有向则称强连通分量</code></p>

<h3>12.生成树</h3>

<p>无向图中连通且n个顶点n-1条边叫生成树。有向图中一顶点的入度为0其余顶点的入度为1的叫做有向树。一个有向图由若干棵有向树构成<strong>生成森林</strong></p>

<h2>二.图的存储方式</h2>

<p>&emsp;由于图的结构复杂，一般的顺序存储方式无法表示。前辈们总结了主要五种不同的表示方法。分别如下：</p>

<h3>邻接矩阵法</h3>

<p>此方法主要思路是将单个顶点的内容和顶点之间的联系独立存储。其中用一个一维数组来存储顶点的内容。用一个二维数组来存储顶点之间的联系（即邻接矩阵）</p>

<p><strong>Code</strong></p>

<p>```c
typedef char VertexType  //define the vertex type
typedef int EdgeType     //define the value of edge</p>

<h1>define MAXVEX 100      //define the max vertex number</h1>

<h1>define INFINITY 65536  //set the 65536 indicates the infinity</h1>

<p>typedef struct {</p>

<pre><code>VertexType  vexs[MAXVEX];
EdgeType edge[MAXVEX][MAXVEX];
int numVertexes, numEdges;
</code></pre>

<p>}MGraph;</p>

<p>```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[树]]></title>
    <link href="http://Albert0010.github.io/blog/2013/08/17/title/"/>
    <updated>2013-08-17T10:39:00+08:00</updated>
    <id>http://Albert0010.github.io/blog/2013/08/17/title</id>
    <content type="html"><![CDATA[<h2>基本概念</h2>

<p>1.斜树</p>

<blockquote><p>所有的结点都只有左子树的二叉树叫左斜树。所有的结点都只有右子树的二叉树叫做右斜树。两者都称谓斜树。</p></blockquote>

<p>2.满二叉树</p>

<blockquote><p>在一棵二叉树中，所有的结点都有左子树和右子树，并且所有的叶子结点都在都一层上,这样的树叫满二叉树。 哈哈，只可惜此事古难全&hellip;</p></blockquote>

<!--more-->


<p>3.完全二叉树</p>

<blockquote><p>对一颗具有n个结点的二叉树按层编号，如果编号为i( 1 &lt;= i &lt;= n ) 的结点与满二叉树的编号相同，就称为完全二叉树。（叶子结点不一定在同一层上）</p></blockquote>

<p>4.线索二叉树</p>

<blockquote><p>在结点数为n的二叉树中，有n-1个分支线数，指针域有2n个，故空指针域有n+1个，用这些空指针域存储遍历后的序列的前驱和后继，这样形成的二叉树就是线索二叉树(Threaded Binary Tree)。其中用于指向前驱和后继的指针称为线索。</p></blockquote>

<h2>遍历</h2>

<blockquote><p>前序，中序和后序遍历中的序强调的是根结点的访问顺序，如果首先访问根结点，然后访问左子树，最后访问右子树，则称为前序遍历。其他类似。 另外还有按层访问的遍历方法等</p></blockquote>

<p>好吧，这几天一直在修改线索二叉树的代码，大脑都有些转不过来了。。。今天偷偷懒，写写博客休息下。。。</p>

<p>基本二叉树的相关代码</p>

<p>```c</p>

<h1>include &lt;stdio.h></h1>

<h1>include &lt;unistd.h></h1>

<h1>include &lt;stdlib.h></h1>

<p>typedef char TElemType;</p>

<p>typedef struct BiTNode
{</p>

<pre><code>TElemType data;
struct BiTNode * lchild, * rchild;
</code></pre>

<p>}BiTNode, *PBiTree;</p>

<p>void PreOrderTraverse(PBiTree );
void InOrderTraverse(PBiTree );
void PostOrderTraverse(PBiTree);
void CreateBiTree(PBiTree *);</p>

<p>int
main(void)
{</p>

<pre><code>PBiTree T;
CreateBiTree(&amp;T);

printf("\nPerOrderTraverse : \n");
PreOrderTraverse(T);
printf("\nInOrderTraverse : \n");
InOrderTraverse(T);
printf("\nPostOrderTraverse : \n");
PostOrderTraverse(T);
printf("\n");
return 0;
</code></pre>

<p>}</p>

<p>void CreateBiTree(PBiTree *T){</p>

<pre><code>TElemType ch;
int num = scanf("%c", &amp;ch);

if( '#' == ch ){ 
     *T = NULL;
     return ;
}
else{
     *T = (PBiTree) malloc(sizeof(BiTNode)); 

     if ( !T  ) {
         return;
     }
     (*T)-&gt; data = ch;
     CreateBiTree (&amp;(*T)-&gt;lchild);
     CreateBiTree (&amp;(*T)-&gt;rchild);
}
</code></pre>

<p>}</p>

<p>void PreOrderTraverse(PBiTree T){</p>

<pre><code>if (NULL == T) return;

printf("%c", T-&gt;data);
PreOrderTraverse(T-&gt;lchild);
PreOrderTraverse(T-&gt;rchild);
</code></pre>

<p>}</p>

<p>void InOrderTraverse(PBiTree T) {</p>

<pre><code>if ( NULL == T ) return;

InOrderTraverse( T-&gt;lchild );
printf("%c", T-&gt;data);
InOrderTraverse( T-&gt;rchild );
</code></pre>

<p>}</p>

<p>void PostOrderTraverse(PBiTree T) {</p>

<pre><code>if (NULL == T) return;

PostOrderTraverse(T-&gt;lchild);
PostOrderTraverse( T-&gt;rchild );
printf("%c", T-&gt;data);
</code></pre>

<p>}
```
编译时把所有的警告都打印出来</p>

<h3>any warning is a problem, we must fix it</h3>

<p><code>gcc -Wall -Wextra -Wstrict-prototypes -Wold-style-defination -Wmissing-prototypes -c binary.c -o tree1</code></p>

<h3>在此，笑谈下写代码的感受</h3>

<p><a href="http://www.stackoverflow.com">StackOverflow</a></p>

<p>代码出现问题时这绝对是个helper and tutor， 这次代码总是有问题，于是第一次试着在网站上发问了(<a href="http://stackoverflow.com/questions/18305889/how-to-end-the-binary-tree-when-create-it">qustion link</a>).虽然老早就注册了，但从来没用过&hellip;惊喜的是，不到几分钟就有一位 experienced c programmer给评论了，而且问题稀里哗啦的就解决了，最后还帮我解决了些其他问题. 在此特别感谢<strong>Jonathon Leffler</strong> : <em>Thank you for your help and tutoring!</em></p>
]]></content>
  </entry>
  
</feed>
