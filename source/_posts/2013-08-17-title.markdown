---
layout: post
title: "树"
date: 2013-08-17 10:39
comments: true

categories: [Data Structure] 
---

##基本概念

1.斜树
>所有的结点都只有左子树的二叉树叫左斜树。所有的结点都只有右子树的二叉树叫做右斜树。两者都称谓斜树。

2.满二叉树

>在一棵二叉树中，所有的结点都有左子树和右子树，并且所有的叶子结点都在都一层上,这样的树叫满二叉树。 哈哈，只可惜此事古难全...

<!--more-->
3.完全二叉树

>对一颗具有n个结点的二叉树按层编号，如果编号为i( 1 <= i <= n ) 的结点与满二叉树的编号相同，就称为完全二叉树。（叶子结点不一定在同一层上）

4.线索二叉树

>在结点数为n的二叉树中，有n-1个分支线数，指针域有2n个，故空指针域有n+1个，用这些空指针域存储遍历后的序列的前驱和后继，这样形成的二叉树就是线索二叉树(Threaded Binary Tree)。其中用于指向前驱和后继的指针称为线索。


##遍历

>前序，中序和后序遍历中的序强调的是根结点的访问顺序，如果首先访问根结点，然后访问左子树，最后访问右子树，则称为前序遍历。其他类似。 另外还有按层访问的遍历方法等

好吧，这几天一直在修改线索二叉树的代码，大脑都有些转不过来了。。。今天偷偷懒，写写博客休息下。。。

基本二叉树的相关代码

```c
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>


typedef char TElemType;

typedef struct BiTNode
{
    TElemType data;
    struct BiTNode * lchild, * rchild;
}BiTNode, *PBiTree;


void PreOrderTraverse(PBiTree );
void InOrderTraverse(PBiTree );
void PostOrderTraverse(PBiTree);
void CreateBiTree(PBiTree *);


int 
main(void)
{
    PBiTree T;
    CreateBiTree(&T);

    printf("\nPerOrderTraverse : \n");
    PreOrderTraverse(T);
    printf("\nInOrderTraverse : \n");
    InOrderTraverse(T);
    printf("\nPostOrderTraverse : \n");
    PostOrderTraverse(T);
    printf("\n");
    return 0;
}


void CreateBiTree(PBiTree *T){
    TElemType ch;
    int num = scanf("%c", &ch);

    if( '#' == ch ){ 
         *T = NULL;
         return ;
    }
    else{
         *T = (PBiTree) malloc(sizeof(BiTNode)); 

         if ( !T  ) {
             return;
         }
         (*T)-> data = ch;
         CreateBiTree (&(*T)->lchild);
         CreateBiTree (&(*T)->rchild);
    }
   
}


void PreOrderTraverse(PBiTree T){
    if (NULL == T) return;

    printf("%c", T->data);
    PreOrderTraverse(T->lchild);
    PreOrderTraverse(T->rchild);
}


void InOrderTraverse(PBiTree T) {
    if ( NULL == T ) return;
    
    InOrderTraverse( T->lchild );
    printf("%c", T->data);
    InOrderTraverse( T->rchild );
}


void PostOrderTraverse(PBiTree T) {
    if (NULL == T) return;

    PostOrderTraverse(T->lchild);
    PostOrderTraverse( T->rchild );
    printf("%c", T->data);
}
```
编译时把所有的警告都打印出来
###any warning is a problem, we must fix it

`gcc -Wall -Wextra -Wstrict-prototypes -Wold-style-defination -Wmissing-prototypes -c binary.c -o tree1`

###在此，笑谈下写代码的感受

[StackOverflow](http://www.stackoverflow.com)

代码出现问题时这绝对是个helper and tutor， 这次代码总是有问题，于是第一次试着在网站上发问了([qustion link](http://stackoverflow.com/questions/18305889/how-to-end-the-binary-tree-when-create-it)).虽然老早就注册了，但从来没用过...惊喜的是，不到几分钟就有一位 experienced c programmer给评论了，而且问题稀里哗啦的就解决了，最后还帮我解决了些其他问题. 在此特别感谢**Jonathon Leffler** : *Thank you for your help and tutoring!* 
